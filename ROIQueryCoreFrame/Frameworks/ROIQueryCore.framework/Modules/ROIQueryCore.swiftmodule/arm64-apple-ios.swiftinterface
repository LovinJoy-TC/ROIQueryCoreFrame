// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target arm64-apple-ios12.3 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ROIQueryCore
import AdServices
import CoreGraphics
import CoreTelephony
import Foundation
@_exported import ROIQueryCore
import SQLite
import Swift
import SystemConfiguration
import UIKit
public typealias AnnotatedTime = (date: Foundation.Date, timeSinceLastNtpSync: Foundation.TimeInterval)
public struct Clock {
  public static var storage: ROIQueryCore.TimeStorage
  public static var timestamp: Foundation.TimeInterval? {
    get
  }
  public static var now: Foundation.Date? {
    get
  }
  public static var annotatedNow: ROIQueryCore.AnnotatedTime? {
    get
  }
  public static func sync(from pool: Swift.String = "time.apple.com", samples: Swift.Int = 4, first: ((Foundation.Date, Foundation.TimeInterval) -> Swift.Void)? = nil, completion: ((Foundation.Date?, Foundation.TimeInterval?) -> Swift.Void)? = nil)
  public static func reset()
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ROIQueryIAPReport : ObjectiveC.NSObject {
  @objc public static func reportEntrance(order: Swift.String, sku: Swift.String, price: Swift.Double, currency: Swift.String, seq: Swift.String, entrance: Swift.String? = "")
  @objc public static func reportToPurchase(order: Swift.String, sku: Swift.String, price: Swift.Double, currency: Swift.String, seq: Swift.String, entrance: Swift.String? = "")
  @objc public static func reportPurchased(order: Swift.String, sku: Swift.String, price: Swift.Double, currency: Swift.String, seq: Swift.String, entrance: Swift.String? = "")
  @objc public static func reportNotToPurchased(order: Swift.String, sku: Swift.String, price: Swift.Double, currency: Swift.String, seq: Swift.String, code: Swift.String, msg: Swift.String? = "", entrance: Swift.String? = "")
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ROIQueryAnalytics : ObjectiveC.NSObject {
  @objc public static func getROIQueryId() -> Swift.String
  @objc public static func track(eventName: Swift.String, properties: [Swift.String : Any]? = [:])
  @objc public static func setAccountId(accountId: Swift.String)
  @objc public static func setFirebaseAppInstanceID(fiid: Swift.String)
  @objc public static func setAppsFlyerID(afuid: Swift.String)
  @objc public static func setKochavaID(koid: Swift.String)
  @objc public static func trackAppClose(properties: [Swift.String : Any] = [:])
  @objc public static func trackPageOpen(properties: [Swift.String : Any] = [:])
  @objc public static func trackPageClose(properties: [Swift.String : Any] = [:])
  @objc public static func setUserProperties(properties: [Swift.String : Any])
  @objc public static func flush()
  @objc public static func onAppForeground()
  @objc public static func onAppBackground()
  @objc override dynamic public init()
  @objc deinit
}
public enum TimeStoragePolicy {
  case standard
  case appGroup(Swift.String)
  public init(appGroupID: Swift.String?)
}
public struct TimeStorage {
  public init(storagePolicy: ROIQueryCore.TimeStoragePolicy)
}
public enum HTTPFile {
  case url(Foundation.URL, Swift.String?)
  case data(Swift.String, Foundation.Data, Swift.String?)
  case text(Swift.String, Swift.String, Swift.String?)
}
public enum HTTPMethod : Swift.String {
  case delete
  case get
  case head
  case options
  case patch
  case post
  case put
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol URLComponentsConvertible {
  var urlComponents: Foundation.URLComponents? { get }
}
extension String : ROIQueryCore.URLComponentsConvertible {
  public var urlComponents: Foundation.URLComponents? {
    get
  }
}
extension URL : ROIQueryCore.URLComponentsConvertible {
  public var urlComponents: Foundation.URLComponents? {
    get
  }
}
@objc final public class HTTPResult : ObjectiveC.NSObject {
  final public var content: Foundation.Data?
  final public var response: Foundation.URLResponse?
  final public var error: Swift.Error?
  final public var request: Foundation.URLRequest? {
    get
  }
  final public var task: Foundation.URLSessionTask?
  final public var encoding: Swift.String.Encoding
  final public var JSONReadingOptions: Foundation.JSONSerialization.ReadingOptions
  final public var reason: Swift.String {
    get
  }
  final public var isRedirect: Swift.Bool {
    get
  }
  final public var isPermanentRedirect: Swift.Bool {
    get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  public init(data: Foundation.Data?, response: Foundation.URLResponse?, error: Swift.Error?, task: Foundation.URLSessionTask?)
  final public var json: Any? {
    get
  }
  final public var statusCode: Swift.Int? {
    get
  }
  final public var text: Swift.String? {
    get
  }
  final public var headers: ROIQueryCore.CaseInsensitiveDictionary<Swift.String, Swift.String> {
    get
    set
  }
  final public var cookies: [Swift.String : Foundation.HTTPCookie] {
    get
    set
  }
  final public var ok: Swift.Bool {
    get
  }
  final public var url: Foundation.URL? {
    get
  }
  final public var links: [Swift.String : [Swift.String : Swift.String]] {
    get
    set
  }
  final public func cancel()
  @objc override dynamic public init()
  @objc deinit
}
public struct CaseInsensitiveDictionary<Key, Value> : Swift.Collection, Swift.ExpressibleByDictionaryLiteral where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  public typealias Index = Swift.DictionaryIndex<Key, Value>
  public var startIndex: ROIQueryCore.CaseInsensitiveDictionary<Key, Value>.Index {
    get
  }
  public var endIndex: ROIQueryCore.CaseInsensitiveDictionary<Key, Value>.Index {
    get
  }
  public func index(after: ROIQueryCore.CaseInsensitiveDictionary<Key, Value>.Index) -> ROIQueryCore.CaseInsensitiveDictionary<Key, Value>.Index
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public init(dictionaryLiteral elements: (Key, Value)...)
  public init(dictionary: [Key : Value])
  public subscript(position: ROIQueryCore.CaseInsensitiveDictionary<Key, Value>.Index) -> ROIQueryCore.CaseInsensitiveDictionary<Key, Value>.Element {
    get
  }
  public subscript(key: Key) -> Value? {
    get
    set(newValue)
  }
  public func makeIterator() -> Swift.DictionaryIterator<Key, Value>
  public var keys: Swift.Dictionary<Key, Value>.Keys {
    get
  }
  public var values: Swift.Dictionary<Key, Value>.Values {
    get
  }
  public typealias Indices = Swift.DefaultIndices<ROIQueryCore.CaseInsensitiveDictionary<Key, Value>>
  public typealias Iterator = Swift.DictionaryIterator<Key, Value>
  public typealias SubSequence = Swift.Slice<ROIQueryCore.CaseInsensitiveDictionary<Key, Value>>
}
public typealias Credentials = (username: Swift.String, password: Swift.String)
public typealias TaskProgressHandler = (ROIQueryCore.HTTPProgress) -> Swift.Void
public struct JustSessionDefaults {
  public var JSONReadingOptions: Foundation.JSONSerialization.ReadingOptions
  public var JSONWritingOptions: Foundation.JSONSerialization.WritingOptions
  public var headers: [Swift.String : Swift.String]
  public var multipartBoundary: Swift.String
  public var credentialPersistence: Foundation.URLCredential.Persistence
  public var encoding: Swift.String.Encoding
  public var cachePolicy: Foundation.NSURLRequest.CachePolicy
  public init(JSONReadingOptions: Foundation.JSONSerialization.ReadingOptions = JSONSerialization.ReadingOptions(rawValue: 0), JSONWritingOptions: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0), headers: [Swift.String : Swift.String] = [:], multipartBoundary: Swift.String = "Ju5tH77P15Aw350m3", credentialPersistence: Foundation.URLCredential.Persistence = .forSession, encoding: Swift.String.Encoding = String.Encoding.utf8, cachePolicy: Foundation.NSURLRequest.CachePolicy = .reloadIgnoringLocalCacheData)
}
public struct HTTPProgress {
  public enum `Type` {
    case upload
    case download
    public static func == (a: ROIQueryCore.HTTPProgress.`Type`, b: ROIQueryCore.HTTPProgress.`Type`) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let type: ROIQueryCore.HTTPProgress.`Type`
  public let bytesProcessed: Swift.Int64
  public let bytesExpectedToProcess: Swift.Int64
  public var chunk: Foundation.Data?
  public var percent: Swift.Float {
    get
  }
}
public protocol JustAdaptor {
  func request(_ method: ROIQueryCore.HTTPMethod, url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any], data: [Swift.String : Any], json: Any?, headers: [Swift.String : Swift.String], files: [Swift.String : ROIQueryCore.HTTPFile], auth: ROIQueryCore.Credentials?, cookies: [Swift.String : Swift.String], redirects: Swift.Bool, timeout: Swift.Double?, urlQuery: Swift.String?, requestBody: Foundation.Data?, asyncProgressHandler: ROIQueryCore.TaskProgressHandler?, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)?) -> ROIQueryCore.HTTPResult
  init(session: Foundation.URLSession?, defaults: ROIQueryCore.JustSessionDefaults?)
}
public struct JustOf<Adaptor> where Adaptor : ROIQueryCore.JustAdaptor {
  public init(session: Foundation.URLSession? = nil, defaults: ROIQueryCore.JustSessionDefaults? = nil)
}
extension JustOf {
  @discardableResult
  public func request(_ method: ROIQueryCore.HTTPMethod, url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func delete(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func get(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func head(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func options(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func patch(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func post(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
  @discardableResult
  public func put(_ url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any] = [:], data: [Swift.String : Any] = [:], json: Any? = nil, headers: [Swift.String : Swift.String] = [:], files: [Swift.String : ROIQueryCore.HTTPFile] = [:], auth: (Swift.String, Swift.String)? = nil, cookies: [Swift.String : Swift.String] = [:], allowRedirects: Swift.Bool = true, timeout: Swift.Double? = nil, urlQuery: Swift.String? = nil, requestBody: Foundation.Data? = nil, asyncProgressHandler: (ROIQueryCore.TaskProgressHandler)? = nil, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)? = nil) -> ROIQueryCore.HTTPResult
}
@objc final public class HTTP : ObjectiveC.NSObject, Foundation.URLSessionDelegate, ROIQueryCore.JustAdaptor {
  public init(session: Foundation.URLSession? = nil, defaults: ROIQueryCore.JustSessionDefaults? = nil)
  final public func synthesizeRequest(_ method: ROIQueryCore.HTTPMethod, url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any], data: [Swift.String : Any], json: Any?, headers: ROIQueryCore.CaseInsensitiveDictionary<Swift.String, Swift.String>, files: [Swift.String : ROIQueryCore.HTTPFile], auth: ROIQueryCore.Credentials?, timeout: Swift.Double?, urlQuery: Swift.String?, requestBody: Foundation.Data?) -> Foundation.URLRequest?
  final public func request(_ method: ROIQueryCore.HTTPMethod, url: ROIQueryCore.URLComponentsConvertible, params: [Swift.String : Any], data: [Swift.String : Any], json: Any?, headers: [Swift.String : Swift.String], files: [Swift.String : ROIQueryCore.HTTPFile], auth: ROIQueryCore.Credentials?, cookies: [Swift.String : Swift.String], redirects: Swift.Bool, timeout: Swift.Double?, urlQuery: Swift.String?, requestBody: Foundation.Data?, asyncProgressHandler: ROIQueryCore.TaskProgressHandler?, asyncCompletionHandler: ((ROIQueryCore.HTTPResult) -> Swift.Void)?) -> ROIQueryCore.HTTPResult
  @objc override dynamic public init()
  @objc deinit
}
extension HTTP : Foundation.URLSessionTaskDelegate, Foundation.URLSessionDataDelegate {
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
public let Just: ROIQueryCore.JustOf<ROIQueryCore.HTTP>
@objc @_inheritsConvenienceInitializers @objcMembers public class ROIQueryCloudConfig : ObjectiveC.NSObject {
  @objc public class func getString(key: Swift.String, fallback: Swift.String = "") -> Swift.String
  @objc public class func getBoolean(key: Swift.String, fallback: Swift.Bool = false) -> Swift.Bool
  @objc public class func getNumber(key: Swift.String, fallback: Foundation.NSNumber = 0) -> Foundation.NSNumber
  @objc public class func getJsonDic(key: Swift.String, fallback: [Swift.String : Any] = [:]) -> [Swift.String : Any]
  @objc public class func getJsonString(key: Swift.String, fallback: Swift.String = "{}") -> Swift.String
  @objc public class func getConfig() -> [Swift.String : Any]
  @objc public class func fetch()
  @objc public class func fetch(success: @escaping () -> Swift.Void, error: @escaping (Swift.String) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
open class KeychainWrapper {
  @available(*, deprecated, message: "KeychainWrapper.defaultKeychainWrapper is deprecated since version 2.2.1, use KeychainWrapper.standard instead")
  public static let defaultKeychainWrapper: ROIQueryCore.KeychainWrapper
  public static let standard: ROIQueryCore.KeychainWrapper
  public var serviceName: Swift.String {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public init(serviceName: Swift.String, accessGroup: Swift.String? = nil)
  open func hasValue(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  open func accessibilityOfKey(_ key: Swift.String) -> ROIQueryCore.KeychainItemAccessibility?
  open func allKeys() -> Swift.Set<Swift.String>
  open func integer(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Int?
  open func float(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Float?
  open func double(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Double?
  open func bool(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool?
  open func string(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.String?
  open func object(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.NSCoding?
  open func data(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.Data?
  open func dataRef(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.Data?
  @discardableResult
  open func set(_ value: Swift.Int, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Float, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Double, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.NSCoding, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @available(*, deprecated, message: "remove is deprecated since version 2.2.1, use removeObject instead")
  @discardableResult
  open func remove(key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func removeObject(forKey key: Swift.String, withAccessibility accessibility: ROIQueryCore.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func removeAllKeys() -> Swift.Bool
  open class func wipeKeychain()
  @objc deinit
}
extension KeychainWrapper {
  public func remove(forKey key: ROIQueryCore.KeychainWrapper.Key)
}
extension KeychainWrapper {
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> Swift.String? {
    get
    set
  }
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Bool? {
    get
    set
  }
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Int? {
    get
    set
  }
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Double? {
    get
    set
  }
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Float? {
    get
    set
  }
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> CoreGraphics.CGFloat? {
    get
    set
  }
  public subscript(key: ROIQueryCore.KeychainWrapper.Key) -> Foundation.Data? {
    get
    set
  }
}
extension KeychainWrapper {
  public func data(forKey key: ROIQueryCore.KeychainWrapper.Key) -> Foundation.Data?
  public func bool(forKey key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Bool?
  public func integer(forKey key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Int?
  public func float(forKey key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Float?
  public func cgFloat(forKey key: ROIQueryCore.KeychainWrapper.Key) -> CoreGraphics.CGFloat?
  public func double(forKey key: ROIQueryCore.KeychainWrapper.Key) -> Swift.Double?
  public func string(forKey key: ROIQueryCore.KeychainWrapper.Key) -> Swift.String?
}
extension KeychainWrapper {
  public struct Key : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(stringLiteral value: Swift.String)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias RawValue = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ROIQueryIasReport : ObjectiveC.NSObject {
  @objc public static func reportToShow(iasSeq: Swift.String, iasEntrance: Swift.String? = nil, iasPlacement: Swift.String)
  @objc public static func reportShowSuccess(iasSeq: Swift.String, iasEntrance: Swift.String? = nil, iasPlacement: Swift.String)
  @objc public static func reportShowFail(iasSeq: Swift.String, iasEntrance: Swift.String? = nil, iasPlacement: Swift.String, iasCode: Swift.String, iasMsg: Swift.String? = nil)
  @objc public static func reportSubscribe(iasSeq: Swift.String, iasEntrance: Swift.String? = nil, iasPlacement: Swift.String, iasSku: Swift.String, iasOrderId: Swift.String, iasPrice: Swift.String, iasCurrency: Swift.String)
  @objc public static func reportSubscribeSuccess(iasSeq: Swift.String, iasEntrance: Swift.String? = nil, iasPlacement: Swift.String, iasSku: Swift.String, iasOrderId: Swift.String, iasOriginalOrderId: Swift.String, iasPrice: Swift.String, iasCurrency: Swift.String)
  @objc public static func reportSubscribeFail(iasSeq: Swift.String, iasEntrance: Swift.String? = nil, iasPlacement: Swift.String, iasSku: Swift.String, iasOrderId: Swift.String, iasOriginalOrderId: Swift.String, iasPrice: Swift.String, iasCurrency: Swift.String, iasCode: Swift.String, iasMsg: Swift.String? = nil)
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ROIQuery : ObjectiveC.NSObject {
  @objc public static func initSDK(appid: Swift.String, channel: ROIQueryCore.ROIQueryChannel = .DEFALUT, isDebug: Swift.Bool = false, logLevel: ROIQueryCore.LogDegree = .verbose, commonProperties: [Swift.String : Any]? = nil)
  @objc public static func initSDK(appid: Swift.String, channel: ROIQueryCore.ROIQueryChannel = .DEFALUT, isDebug: Swift.Bool = false, logLevel: ROIQueryCore.LogDegree = .verbose)
  @objc override dynamic public init()
  @objc deinit
}
@inlinable public func SLogError(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) {
    SLog.log(message(), type: .error, file: file, function: function, line: line)
}
@inlinable public func SLogWarn(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) {
    SLog.log(message(), type: .warn, file: file, function: function, line: line)
}
@inlinable public func SLogInfo(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) {
    SLog.log(message(), type: .info, file: file, function: function, line: line)
}
@inlinable public func SLogNet(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) {
    SLog.log(message(), type: .net, file: file, function: function, line: line)
}
@inlinable public func SLogDebug(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) {
    SLog.log(message(), type: .debug, file: file, function: function, line: line)
}
@inlinable public func SLogVerbose(_ message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) {
    SLog.log(message(), type: .verbose, file: file, function: function, line: line)
}
@objc public enum LogDegree : Swift.Int {
  case verbose = 0
  case debug = 1
  case net = 2
  case info = 3
  case warn = 4
  case error = 5
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SLog {
  public static var shouldLog: Swift.Bool
  public static var getLogFileURL: Foundation.URL {
    get
  }
  public static var defaultLogDegree: ROIQueryCore.LogDegree
  public static var showNetLog: Swift.Bool
  public static var maxLogAge: Foundation.TimeInterval?
  public static var addFileLog: Swift.Bool {
    get
    set
  }
  public static func verbose(_ message: Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line)
  public static func debug(_ message: Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line)
  public static func net(_ message: Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line)
  public static func info(_ message: Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line)
  public static func warn(_ message: Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line)
  public static func error(_ message: Swift.String, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line)
  public static func dprint(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
  public static func log(_ message: @autoclosure () -> Swift.String, type: ROIQueryCore.LogDegree, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt)
  @objc deinit
}
public typealias AppStateEventHandler = (ROIQueryCore.AppStateObserver.AppState) -> Swift.Void
@_hasMissingDesignatedInitializers final public class AppStateObserver {
  public enum AppState : Swift.String, Swift.Equatable {
    case didBecomeActive
    case willResignActive
    case willEnterForeground
    case didEnterBackground
    case willTerminate
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
  public static let shared: ROIQueryCore.AppStateObserver
  @discardableResult
  public static func subscribe(_ handler: @escaping ROIQueryCore.AppStateEventHandler) -> ROIQueryCore.AppStateDisposeBag
}
@objc @_hasMissingDesignatedInitializers public class AppStateDisposeBag : ObjectiveC.NSObject {
  public func dispose()
  @objc override dynamic public init()
  @objc deinit
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct SwiftyJSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: ROIQueryCore.SwiftyJSON) throws
  public func merged(with other: ROIQueryCore.SwiftyJSON) throws -> ROIQueryCore.SwiftyJSON
  public var type: ROIQueryCore.`Type` {
    get
  }
  public var error: ROIQueryCore.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: ROIQueryCore.SwiftyJSON {
    get
  }
  public static var null: ROIQueryCore.SwiftyJSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: ROIQueryCore.Index<T>, rhs: ROIQueryCore.Index<T>) -> Swift.Bool
  public static func < (lhs: ROIQueryCore.Index<T>, rhs: ROIQueryCore.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = ROIQueryCore.Index<ROIQueryCore.SwiftyJSON>
public typealias JSONRawIndex = ROIQueryCore.Index<Any>
extension SwiftyJSON : Swift.Collection {
  public typealias Index = ROIQueryCore.JSONRawIndex
  public var startIndex: ROIQueryCore.SwiftyJSON.Index {
    get
  }
  public var endIndex: ROIQueryCore.SwiftyJSON.Index {
    get
  }
  public func index(after i: ROIQueryCore.SwiftyJSON.Index) -> ROIQueryCore.SwiftyJSON.Index
  public subscript(position: ROIQueryCore.SwiftyJSON.Index) -> (Swift.String, ROIQueryCore.SwiftyJSON) {
    get
  }
  public typealias Element = (Swift.String, ROIQueryCore.SwiftyJSON)
  public typealias Indices = Swift.DefaultIndices<ROIQueryCore.SwiftyJSON>
  public typealias Iterator = Swift.IndexingIterator<ROIQueryCore.SwiftyJSON>
  public typealias SubSequence = Swift.Slice<ROIQueryCore.SwiftyJSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: ROIQueryCore.JSONKey { get }
}
extension Int : ROIQueryCore.JSONSubscriptType {
  public var jsonKey: ROIQueryCore.JSONKey {
    get
  }
}
extension String : ROIQueryCore.JSONSubscriptType {
  public var jsonKey: ROIQueryCore.JSONKey {
    get
  }
}
extension SwiftyJSON {
  public subscript(path: [ROIQueryCore.JSONSubscriptType]) -> ROIQueryCore.SwiftyJSON {
    get
    set
  }
  public subscript(path: ROIQueryCore.JSONSubscriptType...) -> ROIQueryCore.SwiftyJSON {
    get
    set
  }
}
extension SwiftyJSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension SwiftyJSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension SwiftyJSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension SwiftyJSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension SwiftyJSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension SwiftyJSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension SwiftyJSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [ROIQueryCore.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension SwiftyJSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SwiftyJSON {
  public var array: [ROIQueryCore.SwiftyJSON]? {
    get
  }
  public var arrayValue: [ROIQueryCore.SwiftyJSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension SwiftyJSON {
  public var dictionary: [Swift.String : ROIQueryCore.SwiftyJSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : ROIQueryCore.SwiftyJSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension SwiftyJSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension SwiftyJSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension SwiftyJSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension SwiftyJSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension SwiftyJSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension SwiftyJSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension SwiftyJSON : Swift.Comparable {
}
public func == (lhs: ROIQueryCore.SwiftyJSON, rhs: ROIQueryCore.SwiftyJSON) -> Swift.Bool
public func <= (lhs: ROIQueryCore.SwiftyJSON, rhs: ROIQueryCore.SwiftyJSON) -> Swift.Bool
public func >= (lhs: ROIQueryCore.SwiftyJSON, rhs: ROIQueryCore.SwiftyJSON) -> Swift.Bool
public func > (lhs: ROIQueryCore.SwiftyJSON, rhs: ROIQueryCore.SwiftyJSON) -> Swift.Bool
public func < (lhs: ROIQueryCore.SwiftyJSON, rhs: ROIQueryCore.SwiftyJSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: ROIQueryCore.writingOptionsKeys, b: ROIQueryCore.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwiftyJSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol CloudConfigFetchCallBack : ObjectiveC.NSObjectProtocol {
  func success(_ result: [Swift.String : Any])
  func error(errorReason: Swift.String)
}
public typealias CloudConfigFetchSuccess = ([Swift.String : Any]) -> Swift.Void
public typealias CloudConfigFetchError = (Swift.String) -> Swift.Void
@objc public enum AdType : Swift.Int {
  case IDLE = -1
  case BANNER = 0
  case INTERSTITIAL = 1
  case NATIVE = 2
  case REWARDED = 3
  case REWARDED_INTERSTITIAL = 4
  case APP_OPEN = 5
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum AdMediation : Swift.Int {
  case IDLE = -1
  case MOPUB = 0
  case IRONSOURCE = 1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum AdPlatform : Swift.Int {
  case UNDISCLOSED = -2
  case IDLE = -1
  case ADMOB = 0
  case MOPUB = 1
  case ADCOLONY = 2
  case APPLOVIN = 3
  case CHARTBOOST = 4
  case FACEBOOK = 5
  case INMOBI = 6
  case IRONSOURCE = 7
  case PANGLE = 8
  case SNAP_AUDIENCE_NETWORK = 9
  case TAPJOY = 10
  case UNITY_ADS = 11
  case VERIZON_MEDIA = 12
  case VUNGLE = 13
  case ADX = 14
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers public class ROIQueryAdReport : ObjectiveC.NSObject {
  @objc public class func reportEntrance(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportToShow(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportShow(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportImpression(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportClick(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportRewarded(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportConversionByClick(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportConversionByLeftApp(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportConversionByImpression(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportConversionByRewarded(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportClose(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportPaid(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, value: Swift.String, currency: Swift.String, precision: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportPaid(id: Swift.String, type: ROIQueryCore.AdType, platform: Swift.String, adgroupType: Swift.String, location: Swift.String, seq: Swift.String, mediation: ROIQueryCore.AdMediation, mediationId: Swift.String, value: Swift.String, currency: Swift.String, precision: Swift.String, country: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func reportLeftApp(id: Swift.String, type: ROIQueryCore.AdType, platform: ROIQueryCore.AdPlatform, location: Swift.String, seq: Swift.String, properties: [Swift.String : Any]? = [:], entrance: Swift.String? = "")
  @objc public class func generateUUID() -> Swift.String
  @objc public class func getPlatform(mediation: Swift.Int, networkName: Swift.String, networkPlacementId: Swift.String, adgroupType: Swift.String) -> ROIQueryCore.AdPlatform
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ROIQueryChannel : Swift.Int {
  case DEFALUT
  case GP
  case APPSTORE
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias Properties = [Swift.String : Any]?
public typealias Rlog = ROIQueryCore.SLog
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (ROIQueryCore.Reachability) -> ()
  public typealias NetworkUnreachable = (ROIQueryCore.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: ROIQueryCore.Reachability.NetworkStatus, b: ROIQueryCore.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: ROIQueryCore.Reachability.Connection
    public static func == (a: ROIQueryCore.Reachability.Connection, b: ROIQueryCore.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: ROIQueryCore.Reachability.NetworkReachable?
  public var whenUnreachable: ROIQueryCore.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: ROIQueryCore.Reachability.Connection {
    get
  }
  public var connection: ROIQueryCore.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public enum KeychainItemAccessibility {
  @available(iOS 4, *)
  case afterFirstUnlock
  @available(iOS 4, *)
  case afterFirstUnlockThisDeviceOnly
  @available(iOS 4, *)
  case always
  @available(iOS 8, *)
  case whenPasscodeSetThisDeviceOnly
  @available(iOS 4, *)
  case alwaysThisDeviceOnly
  @available(iOS 4, *)
  case whenUnlocked
  @available(iOS 4, *)
  case whenUnlockedThisDeviceOnly
  public static func == (a: ROIQueryCore.KeychainItemAccessibility, b: ROIQueryCore.KeychainItemAccessibility) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AdUtils {
  public static func generateUUID() -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers open class GCD {
  public static let shared: ROIQueryCore.GCD
  public static let main: Dispatch.DispatchQueue
  public static let global: Dispatch.DispatchQueue
  public static let globalHigh: Dispatch.DispatchQueue
  public static func seria(label: Swift.String) -> Dispatch.DispatchQueue
  public static func concurrent(label: Swift.String, isConcurrent: Swift.Bool = true) -> Dispatch.DispatchQueue
  open func after(time: Swift.Double, queue: Dispatch.DispatchQueue, callBack: @escaping () -> Swift.Void)
  public typealias DelayTask = (Swift.Bool) -> ()
  @discardableResult
  public func delay(_ time: Foundation.TimeInterval, task: @escaping () -> ()) -> ROIQueryCore.GCD.DelayTask?
  public func cancelDelay(_ task: ROIQueryCore.GCD.DelayTask?)
  open func scheduledDispatchTimer(WithTimerName name: Swift.String?, timeInterval: Swift.Double, queue: Dispatch.DispatchQueue, repeats: Swift.Bool, action: @escaping () -> Swift.Void)
  open func cancleTimer(WithTimerName name: Swift.String?)
  open func isExistTimer(WithTimerName name: Swift.String?) -> Swift.Bool
  @objc deinit
}
extension ROIQueryCore.HTTPMethod : Swift.Equatable {}
extension ROIQueryCore.HTTPMethod : Swift.Hashable {}
extension ROIQueryCore.HTTPMethod : Swift.RawRepresentable {}
extension ROIQueryCore.HTTPProgress.`Type` : Swift.Equatable {}
extension ROIQueryCore.HTTPProgress.`Type` : Swift.Hashable {}
extension ROIQueryCore.LogDegree : Swift.Equatable {}
extension ROIQueryCore.LogDegree : Swift.Hashable {}
extension ROIQueryCore.LogDegree : Swift.RawRepresentable {}
extension ROIQueryCore.AppStateObserver.AppState : Swift.Hashable {}
extension ROIQueryCore.AppStateObserver.AppState : Swift.RawRepresentable {}
extension ROIQueryCore.SwiftyJSONError : Swift.Equatable {}
extension ROIQueryCore.SwiftyJSONError : Swift.Hashable {}
extension ROIQueryCore.SwiftyJSONError : Swift.RawRepresentable {}
extension ROIQueryCore.`Type` : Swift.Equatable {}
extension ROIQueryCore.`Type` : Swift.Hashable {}
extension ROIQueryCore.`Type` : Swift.RawRepresentable {}
extension ROIQueryCore.writingOptionsKeys : Swift.Equatable {}
extension ROIQueryCore.writingOptionsKeys : Swift.Hashable {}
extension ROIQueryCore.AdType : Swift.Equatable {}
extension ROIQueryCore.AdType : Swift.Hashable {}
extension ROIQueryCore.AdType : Swift.RawRepresentable {}
extension ROIQueryCore.AdMediation : Swift.Equatable {}
extension ROIQueryCore.AdMediation : Swift.Hashable {}
extension ROIQueryCore.AdMediation : Swift.RawRepresentable {}
extension ROIQueryCore.AdPlatform : Swift.Equatable {}
extension ROIQueryCore.AdPlatform : Swift.Hashable {}
extension ROIQueryCore.AdPlatform : Swift.RawRepresentable {}
extension ROIQueryCore.ROIQueryChannel : Swift.Equatable {}
extension ROIQueryCore.ROIQueryChannel : Swift.Hashable {}
extension ROIQueryCore.ROIQueryChannel : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension ROIQueryCore.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension ROIQueryCore.Reachability.NetworkStatus : Swift.Hashable {}
extension ROIQueryCore.Reachability.Connection : Swift.Equatable {}
extension ROIQueryCore.Reachability.Connection : Swift.Hashable {}
extension ROIQueryCore.KeychainItemAccessibility : Swift.Equatable {}
extension ROIQueryCore.KeychainItemAccessibility : Swift.Hashable {}
